name: Deploy a workflow in Source Account to process and send data

on:
 workflow_dispatch:
      
permissions:
      id-token: write   # This is required for requesting the JWT
      contents: read 

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v2

    - name: Configure AWS Credentials
      uses: aws-actions/configure-aws-credentials@v1
      with:
         role-to-assume: arn:aws:iam::${{ secrets.ACCOUNT_ID }}:role/${{ secrets.ROLE_NAME }}
         aws-region: ${{ secrets.REGION }}

    - name: Check CloudFormation stack status for EMR and S3
      id: check_status
      run: |
        STACK_NAME="MyEMRS3"
        STACK_STATUS=$(aws cloudformation describe-stacks --stack-name $STACK_NAME --query "Stacks[0].StackStatus" --output text 2>&1 || echo "STACK_DOES_NOT_EXIST")
        if [[ "$STACK_STATUS" == "STACK_DOES_NOT_EXIST" ]]; then
          echo "Stack $STACK_NAME does not exist."
          echo "::set-output name=status::NOT_FOUND"
        else
          echo "Stack status for EMR and S3: $STACK_STATUS"
          echo "::set-output name=status::$STACK_STATUS"
        fi

    # - name: Delete CloudFormation stack EMR and S3
    #   if: steps.check_status.outputs.status != 'CREATE_COMPLETE' && steps.check_status.outputs.status != 'NOT_FOUND'
    #   run: |
    #     echo "Deleting stack MyEMRS3 because status is ${{ steps.check_status.outputs.status }}"
    #     aws cloudformation delete-stack --stack-name MyEMRS3
    #     aws cloudformation wait stack-delete-complete --stack-name MyEMRS3
 
    - name: Deploy EMR and S3 using CloudFormation
      if: steps.check_status.outputs.status != 'CREATE_COMPLETE' && steps.check_status.outputs.status != 'NOT_FOUND'
      run: |
        aws cloudformation deploy \
          --template-file cloudformation/EMR_S3.yaml \
          --stack-name MyEMRS3 \
          --capabilities CAPABILITY_NAMED_IAM
        aws cloudformation wait stack-create-complete --stack-name MyEMRS3

    - name: Check CloudFormation stack status for Glue and Step function
      id: check_status_1
      run: |
        STACK_NAME="MyGlueStepFunction"
        STACK_STATUS_1=$(aws cloudformation describe-stacks --stack-name $STACK_NAME --query "Stacks[0].StackStatus" --output text 2>&1 || echo "STACK_DOES_NOT_EXIST")
        if [[ "$STACK_STATUS_1" == "STACK_DOES_NOT_EXIST" ]]; then
          echo "Stack $STACK_NAME does not exist."
          echo "::set-output name=status_1::NOT_FOUND"
        else
          echo "Stack status for Glue and Step Function: $STACK_STATUS_1"
          echo "::set-output name=status_1::$STACK_STATUS_1"
        fi

    # - name: Delete CloudFormation stack Glue and Step function
    #   if: steps.check_status_1.outputs.status_1 != 'CREATE_COMPLETE' && steps.check_status_1.outputs.status_1 != 'NOT_FOUND'
    #   run: |
    #     echo "Deleting stack MyGlueStepFunction because status is ${{ steps.check_status_1.outputs.status_1 }}"
    #     aws cloudformation delete-stack --stack-name MyGlueStepFunction
    #     aws cloudformation wait stack-delete-complete --stack-name MyGlueStepFunction
 
    - name: Deploy Glue and Step function using CloudFormation
      if: steps.check_status_1.outputs.status_1 != 'CREATE_COMPLETE' && steps.check_status_1.outputs.status_1 != 'NOT_FOUND'
      run: |
        aws cloudformation deploy \
          --template-file cloudformation/Glue_StepFunction.yaml \
          --stack-name MyGlueStepFunction \
          --capabilities CAPABILITY_NAMED_IAM
        aws cloudformation wait stack-create-complete --stack-name MyGlueStepFunction

    - name: Check CloudFormation stack status for RDS Lambda and Secret Manager
      id: check_status_2
      run: |
        STACK_NAME="MyRdsLambdaSecretManager"
        STACK_STATUS_2=$(aws cloudformation describe-stacks --stack-name $STACK_NAME --query "Stacks[0].StackStatus" --output text 2>&1 || echo "STACK_DOES_NOT_EXIST")
        if [[ "$STACK_STATUS_2" == "STACK_DOES_NOT_EXIST" ]]; then
          echo "Stack $STACK_NAME does not exist."
          echo "::set-output name=status_2::NOT_FOUND"
        else
          echo "Stack status for RDS Lambda Secret Manager: $STACK_STATUS_2"
          echo "::set-output name=status_2::$STACK_STATUS_2"
        fi

    # - name: Delete CloudFormation stack
    #   if: steps.check_status_2.outputs.status_2 != 'CREATE_COMPLETE' && steps.check_status_2.outputs.status_2 != 'NOT_FOUND'
    #   run: |
    #     echo "Deleting stack MyRdsLambdaSecretManager because status is ${{ steps.check_status_2.outputs.status_2 }}"
    #     aws cloudformation delete-stack --stack-name MyRdsLambdaSecretManager
    #     aws cloudformation wait stack-delete-complete --stack-name MyRdsLambdaSecretManager

    - name: Create or Update RDS Secret
      if: steps.check_status_2.outputs.status_2 != 'CREATE_COMPLETE' && steps.check_status_2.outputs.status_2 != 'NOT_FOUND'
      run: |
        # Check if secret exists
        if aws secretsmanager describe-secret --secret-id ${{ secrets.SECRET_NAME }} > /dev/null 2>&1; then
           echo "Secret already exists, skipping creation..."
          # Get the existing secret's ARN
          SECRET_ARN=$(aws secretsmanager describe-secret \
          --secret-id ${{ secrets.SECRET_NAME }} \
          --query ARN --output text)
  
          echo "SECRET_ARN=$SECRET_ARN" >> $GITHUB_ENV
        else
          echo "Creating new secret..."
  
          # Generate secure password
          RDS_PASSWORD=$(openssl rand -base64 32)
  
         # Create secret JSON
         SECRET_JSON=$(jq -n \
           --arg username "admin" \
           --arg password "$RDS_PASSWORD" \
           --arg dbname "MyDatabase" \
           --arg engine "mysql" \
           --arg host "localhost" \
           --arg port "3306" \
          '{
            "username": $username,
           "password": $password,
           "dbname": $dbname,
           "engine": $engine,
           "host": $host,
           "port": $port,
           "description": "RDS database credentials"
           }')
  
           # Create new secret
          aws secretsmanager create-secret \
            --name ${{ secrets.SECRET_NAME }} \
            --description "RDS database credentials" \
            --secret-string "$SECRET_JSON"
  
           # Get the ARN of the newly created secret
          SECRET_ARN=$(aws secretsmanager describe-secret \
            --secret-id ${{ secrets.SECRET_NAME }} \
            --query ARN --output text)
  
          echo "SECRET_ARN=$SECRET_ARN" >> $GITHUB_ENV
          echo "New secret created with ARN: $SECRET_ARN"
        fi

    - name: Verify all exports exist
      id: verify_exports
      run: |
          MAX_RETRIES=3
          RETRY_COUNT=0
          
          echo "Waiting for CloudFormation exports to be available..."
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            # Get all required exports
            VPC_ID=$(aws cloudformation list-exports \
              --query "Exports[?Name=='MyVPCId'].Value" \
              --output text 2>/dev/null || echo "")
            
            SUBNET_ID=$(aws cloudformation list-exports \
              --query "Exports[?Name=='MyPrivateSubnetId'].Value" \
              --output text 2>/dev/null || echo "")
            
            STATE_MACHINE_ARN=$(aws cloudformation list-exports \
              --query "Exports[?Name=='MyStateMachineArn'].Value" \
              --output text 2>/dev/null || echo "")
            
            # Check if required exports exist
            if [ -n "$VPC_ID" ] && [ -n "$SUBNET_ID" ] && \
               [ "$VPC_ID" != "None" ] && [ "$SUBNET_ID" != "None" ]; then
              
              echo "✅ VPC exports found!"
              echo "VPC_ID=$VPC_ID" >> $GITHUB_ENV
              echo "SUBNET_ID=$SUBNET_ID" >> $GITHUB_ENV
              
              # Optional: StateMachineArn
              if [ -n "$STATE_MACHINE_ARN" ] && [ "$STATE_MACHINE_ARN" != "None" ]; then
                echo "✅ State machine ARN export found!"
                echo "STATE_MACHINE_ARN=$STATE_MACHINE_ARN" >> $GITHUB_ENV
              else
                echo "⚠️ State machine ARN export not found (optional)"
                echo "STATE_MACHINE_ARN=" >> $GITHUB_ENV
              fi
              
              exit 0
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              echo "Waiting for exports... ($RETRY_COUNT/$MAX_RETRIES)"
              sleep 10
            fi
          done
          
          echo "❌ ERROR: Required exports not found after $MAX_RETRIES retries"
          echo "Debug - Listing all exports:"
          aws cloudformation list-exports --query "Exports[*].[Name,Value]" --output table
          exit 1
 
    - name: Deploy Lambda and RDS using CloudFormation
      if: steps.check_status_2.outputs.status_2 != 'CREATE_COMPLETE' && steps.check_status_2.outputs.status_2 != 'NOT_FOUND'
      run: |
        
        # Then sync all files to S3
        aws s3 sync "DataSourceTransform\MyDataBucket1\" s3://scriptbucketkuangju87/
        
        # Verify upload
        aws s3 ls s3://scriptbucketkuangju87/ --recursive

        # Deploy the RDS stack
        aws cloudformation deploy \
          --template-file cloudformation/RDS_Lambda_SecretManager.yaml \
          --stack-name MyRdsLambdaSecretManager \
          --parameter-overrides \
              RDSSecretArn=${{ env.SECRET_ARN }} \
              VPCId=${{ env.VPC_ID }} \
              PrivateSubnetId=${{ env.SUBNET_ID }} \
              StateMachineArn=${{ env.STATE_MACHINE_ARN }} \
              DBInstanceClass=db.t3.micro \
              DBAllocatedStorage=5 \
              DatabaseName=MyDatabase \
              TableName=UploadedData \
              DataBucket1Name=scriptbucketkuangju87 \
              DataBucket2Name=databucketkuangju87 \
          --capabilities CAPABILITY_NAMED_IAM
          

        aws cloudformation wait stack-create-complete --stack-name MyRdsLambdaSecretManager

    - name: Sync S3 bucket
      run: |
        aws s3 sync MyDataBucket1/ s3://scriptbucket
